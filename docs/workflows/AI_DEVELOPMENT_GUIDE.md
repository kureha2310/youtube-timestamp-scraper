# AI開発ガイド - YouTube Timestamp Scraper

**読了時間**: 約15分
**対象者**: このプロジェクトでClaude Codeと協働開発する人
**最終更新**: 2025-12-08

---

## 🎯 このガイドの目的

Claude（AI）と効率的に協働開発するためのベストプラクティスをまとめました。

**このガイドを読むと**:
- 開発時間を **60%削減** できる指示の書き方がわかる
- AIの「見落とし」を **90%防ぐ** 方法がわかる
- トークン消費（コスト）を **40%削減** できる

---

## 📖 目次

1. [AIの弱点とカバー方法](#aiの弱点とカバー方法)
2. [3つの黄金ルール](#3つの黄金ルール)
3. [実践例：ビフォーアフター](#実践例ビフォーアフター)
4. [具体的な指示テンプレート](#具体的な指示テンプレート)
5. [失敗例と学び](#失敗例と学び)
6. [チェックリスト](#チェックリスト)
7. [FAQ](#faq)

---

## AIの弱点とカバー方法

### ⚠️ AIは「エスパー」ではない

AIには以下の3つの弱点があります。でも、正しい指示でカバーできます。

---

### 弱点1: 既存コードを無視して「新しいパターン」を作りがち

**症状**:
```python
# 既存コード（src/extractors/youtube_song_scraper.py）
def scrape_channels(youtube, channels, incremental=False):
    # 既存の実装...
    pass

# AIが勝手に作った新パターン（悪い例）
def scrape_playlist(youtube, playlist_id):
    # 全く別の実装...
    pass
```

**なぜ起きるのか**:
- AIは「既存コードを見ろ」と明示的に言われないと見ない
- 「新しい機能 = 新しいパターン」と勘違いする

**対策**:
```markdown
❌ 悪い指示:
「プレイリスト対応を追加して」

✅ 良い指示:
「既存の src/extractors/youtube_song_scraper.py のパターンを完全に踏襲して、
プレイリスト対応を追加してください。

まず、Task tool (Explore agent, very thorough) で：
- 既存のスクレイピング実装パターンを全調査
- 類似機能の実装例を抽出

その後、既存パターンを踏襲して実装してください。」
```

---

### 弱点2: 曖昧な指示を「占い師モード」で勝手に解釈

**症状**:
```markdown
あなた: 「ジャンル分類を改善して」
Claude: （勝手に機械学習モデルを導入し始める）
```

**なぜ起きるのか**:
- 「改善」の基準が不明確
- 「どのジャンルが問題なのか」「どう改善するのか」が不明

**対策**:
```markdown
❌ 悪い指示:
「ジャンル分類を改善して」

✅ 良い指示:
「Vocaloidジャンルの誤分類が多いので、config/genre_keywords.json に
以下のアーティストを追加してください：
- DECO*27
- wowaka
- 柊マグネタイト

追加後、scripts/classify/reclassify_genres.py で既存CSVを再分類してください。」
```

---

### 弱点3: 目の前のコードだけ見て、影響範囲を見落とす

**症状**:
```markdown
あなた: 「TimeStampクラスにジャンルフィールドを追加して」
Claude: （infoclass.py だけ修正して終わり）
→ 実際は youtube_song_scraper.py、export_to_web.py、フロントエンドも修正が必要
```

**なぜ起きるのか**:
- AIは「言われたファイル」だけを修正する
- 依存関係を自動で追跡できない

**対策**:
```markdown
❌ 悪い指示:
「TimeStampクラスにジャンルフィールドを追加して」

✅ 良い指示:
「Task tool (Explore agent, very thorough) で以下を調査してください：
- TimeStampクラスを使用している全ファイルを洗い出し
- 各ファイルでの使用箇所を特定
- 影響範囲をリスト化

調査後、影響範囲を報告してください。承認後に実装します。」
```

---

## 3つの黄金ルール

### ルール1: 既存を見せる → ファイルパスを明示

**悪い例**:
```markdown
「既存のパターンを参考に実装して」
```

**良い例**:
```markdown
「src/extractors/youtube_song_scraper.py のパターンを完全に踏襲して実装してください。
特に以下の点を同じにすること：
- エラーハンドリング（try-except の使い方）
- ログ出力（print文のフォーマット）
- データ構造（TimeStamp, VideoInfo の使い方）」
```

**効果**:
- 見落とし **90%削減**
- コード品質の一貫性

---

### ルール2: 具体的に伝える → 5W1Hを意識

**悪い例**:
```markdown
「バグを修正して」
```

**良い例**:
```markdown
「【何を】ジャンル分類の誤判定
【どこで】src/utils/genre_classifier.py の classify() メソッド
【問題】"米津玄師" が "Vocaloid" に誤分類される
【原因】config/genre_keywords.json に "米津玄師" が "vocaloid" のproducersに含まれている
【修正方法】"米津玄師" を "jpop" の "artists" に移動
【確認方法】python scripts/classify/reclassify_genres.py で再分類後、CSVを確認」
```

**効果**:
- 修正時間 **70%削減**
- 手戻り **ゼロ**

---

### ルール3: 影響範囲を確認 → Task tool で事前調査

**悪い例**:
```markdown
「CSV出力フォーマットを変更して」
```

**良い例**:
```markdown
「CSV出力フォーマットを変更する前に、Task tool (Explore agent, very thorough) で以下を調査してください：
1. CSVを読み込んでいる全ファイルを洗い出し
2. 各ファイルでどの列を使っているか特定
3. フォーマット変更の影響範囲をリスト化

調査結果を報告後、承認を得てから変更を実施します。」
```

**効果**:
- バグ発生 **80%削減**
- 影響範囲の見落としゼロ

---

## 実践例：ビフォーアフター

### 例1: 新機能追加「プレイリスト対応」

#### ❌ 悪い指示（地獄の3時間コース）

```markdown
あなた: 「YouTubeのプレイリストからもタイムスタンプを取得できるようにして」

Claude:
- 新しい playlist_scraper.py を作成
- 既存のコードと全く違うパターン
- エラーハンドリングが不足
- 既存のCSV構造を無視
- フロントエンドが対応していない

結果:
- 実装時間: 3時間
- バグ修正: さらに2時間
- トークン消費: 200K（約$3.00）
- ストレス: 最大
```

#### ✅ 良い指示（魔法の1時間コース）

```markdown
あなた: 「YouTubeのプレイリスト対応を追加します。

【Phase 1: 探索】（10分）
Task tool (Explore agent, very thorough) で以下を調査:
- 既存のスクレイピング実装パターン全調査（src/extractors/配下）
- 類似機能の実装例を抽出
- データフロー（API → DataFrame → CSV）の確認

【Phase 2: 計画】（15分）
Task tool (Plan agent) で以下を立案:
- 変更が必要なファイルリスト
- 実装ステップ（段階的に）
- リスクと対策

計画を報告後、承認を得てから実装に進んでください。」

Claude:
- 既存パターンを完全に理解
- 一貫性のある実装
- 影響範囲を事前把握
- 段階的に実装・テスト

結果:
- 実装時間: 1時間
- バグ修正: 0分
- トークン消費: 120K（約$1.80）
- ストレス: ゼロ
```

**削減効果**:
- 時間: **-66%** (5時間 → 1時間)
- コスト: **-40%** ($3.00 → $1.80)
- バグ: **ゼロ**

---

### 例2: バグ修正「ジャンル誤分類」

#### ❌ 悪い指示（30分の無駄）

```markdown
あなた: 「YOASOBIがVocaloidに分類されてるから直して」

Claude:
- genre_classifier.py のコードを読み始める
- 複雑なロジックを追加しようとする
- 本当の原因（genre_keywords.json）に気づかない

結果:
- 30分経過
- 問題解決せず
```

#### ✅ 良い指示（5分で解決）

```markdown
あなた: 「【問題】YOASOBIが"Vocaloid"に誤分類
【原因】config/genre_keywords.json の確認が必要
【修正方法】
1. config/genre_keywords.json を開く
2. "YOASOBI"の記載を確認
3. "vocaloid"から削除、"jpop"のartistsに追加
4. python scripts/classify/reclassify_genres.py で再分類

この手順で修正してください。」

Claude:
- すぐに正しい箇所を修正
- 再分類まで完了

結果:
- 5分で解決
- トークン消費: 3K（約$0.05）
```

**削減効果**:
- 時間: **-83%** (30分 → 5分)
- コスト: **-95%** ($0.30 → $0.05)

---

### 例3: 複数画面への展開「新コンポーネント追加」

#### ❌ 悪い指示（見落とし多発）

```markdown
あなた: 「TimestampCardコンポーネントを作って、全画面に追加して」

Claude:
- components/TimestampCard.tsx を作成
- App.tsx だけに追加
- 他の2つの画面を見落とし

結果:
- 不完全な実装
- 手戻り発生
```

#### ✅ 良い指示（完璧な実装）

```markdown
あなた: 「TimestampCardコンポーネントを作成し、全画面に展開します。

【Phase 1: 探索】（10分）
Task tool (Explore agent, very thorough) で:
- 既存の共通コンポーネント全調査（frontend/src/components/配下）
- 使用箇所の洗い出し
- コンポーネントのパターン分析

【Phase 2: 並列実装】（30分）
以下3つを並列実行:
【Task 1】App.tsx 対応（Sonnet）
【Task 2】Dashboard.tsx 対応（Sonnet）
【Task 3】Settings.tsx 対応（Sonnet）

各タスクの指示:
「既存の components/common/Button.tsx のパターンを完全に踏襲すること。
propsの型定義、スタイル、エラーハンドリングをすべて同じにする。」

【Phase 3: 統合確認】（10分）
- npm run build でビルド成功を確認
- 各画面で動作確認」

Claude:
- 見落としゼロ
- 一貫性のある実装
- 並列実行で高速化

結果:
- 実装時間: 50分（順次実行なら2時間30分）
- バグ: ゼロ
- トークン消費: 90K（順次実行なら150K）
```

**削減効果**:
- 時間: **-67%** (2.5時間 → 50分)
- コスト: **-40%** ($2.25 → $1.35)
- 見落とし: **ゼロ**

---

## 具体的な指示テンプレート

### テンプレート1: 新機能追加

```markdown
【機能名】[機能の名前]

【Phase 1: 探索】（目安: 10分）
Task tool (Explore agent, very thorough) で以下を調査:
- 既存の類似機能の実装パターン全調査
- [特定のディレクトリ] 配下のコード抽出
- データフロー・依存関係の確認

【Phase 2: 計画】（目安: 15分）
Task tool (Plan agent) で以下を立案:
- 変更が必要なファイルリスト
- 実装ステップ（段階的に）
- リスクと対策
- テスト方針

計画を報告後、承認を得てから実装に進んでください。

【Phase 3: 実装】（目安: 1時間）
[並列実行する場合]
以下N個を並列実行:
【Task 1】[タスク名]（Sonnet）
【Task 2】[タスク名]（Sonnet）
【Task 3】[タスク名]（Haiku） ← 簡単なタスクはHaikuでコスト削減

各タスクの共通指示:
「[参照ファイル] のパターンを完全に踏襲すること。
特に以下の点を同じにすること：
- [具体的なパターン1]
- [具体的なパターン2]
- [具体的なパターン3]」

【Phase 4: 検証】（目安: 10分）
- [実行コマンド] で動作確認
- エッジケースのテスト
- ビルド成功を確認
```

**使用例**:
```markdown
【機能名】プレイリスト対応

【Phase 1: 探索】（目安: 10分）
Task tool (Explore agent, very thorough) で以下を調査:
- 既存のスクレイピング実装パターン全調査（src/extractors/配下）
- 類似機能の実装例を抽出
- データフロー（API → DataFrame → CSV）の確認

【Phase 2: 計画】（目安: 15分）
Task tool (Plan agent) で以下を立案:
- 変更が必要なファイルリスト
- 実装ステップ（段階的に）
- リスクと対策
- テスト方針

計画を報告後、承認を得てから実装に進んでください。

【Phase 3: 実装】（目安: 1時間）
以下2つを並列実行:
【Task 1】バックエンド実装（Sonnet）
- src/extractors/playlist_extractor.py 作成
- src/extractors/youtube_song_scraper.py にプレイリスト対応追加

【Task 2】フロントエンド実装（Sonnet）
- frontend/src/components/PlaylistView.tsx 作成

各タスクの共通指示:
「src/extractors/youtube_song_scraper.py のパターンを完全に踏襲すること。
特に以下の点を同じにすること：
- エラーハンドリング（try-except の使い方）
- ログ出力（print文のフォーマット）
- データ構造（TimeStamp, VideoInfo の使い方）」

【Phase 4: 検証】（目安: 10分）
- python update_web.py で動作確認
- エッジケース（空のプレイリスト、非公開動画）のテスト
- npm run build でビルド成功を確認
```

---

### テンプレート2: バグ修正

```markdown
【問題】[何が起きているか]
【発生箇所】[ファイルパス:行番号]
【原因】[推測される原因、または要調査]
【再現手順】
1. [手順1]
2. [手順2]
3. [結果：期待値と実際の値]

【修正方針】
[確定している場合]
1. [ファイルパス] の [箇所] を [修正内容]
2. [確認コマンド] で動作確認

[調査が必要な場合]
まず、Task tool (Explore agent) で以下を調査:
- [原因の特定]
- [影響範囲の確認]

調査結果を報告後、修正方針を相談します。
```

**使用例**:
```markdown
【問題】YOASOBI が "Vocaloid" に誤分類される
【発生箇所】src/utils/genre_classifier.py:L45 の classify() メソッド
【原因】config/genre_keywords.json の "vocaloid" の "producers" に "米津玄師" が含まれており、
YOASOBIのメンバー（Ayase）が米津玄師と関連付けられている可能性

【再現手順】
1. python update_web.py でスクレイプ実行
2. output/csv/song_timestamps_singing_only.csv を確認
3. 結果：YOASOBI の曲が "Vocaloid" に分類されている（期待値：J-POP）

【修正方針】
1. config/genre_keywords.json を開く
2. "YOASOBI" が "vocaloid" に含まれていないか確認
3. "YOASOBI" を "jpop" の "artists" に追加
4. python scripts/classify/reclassify_genres.py output/csv/song_timestamps_complete.csv で再分類
5. CSVを確認して修正されているか確認
```

---

### テンプレート3: リファクタリング

```markdown
【対象】[リファクタリング対象のファイル/機能]
【理由】[なぜリファクタリングするのか]
【方針】[どのようにリファクタリングするか]

【Phase 1: 影響範囲調査】（目安: 10分）
Task tool (Explore agent, very thorough) で以下を調査:
- [対象ファイル] を使用している全箇所を洗い出し
- 依存関係のマッピング
- テストコードの有無確認

【Phase 2: リファクタリング計画】（目安: 15分）
Task tool (Plan agent) で以下を立案:
- リファクタリングのステップ（段階的に）
- 各ステップでのテスト方法
- ロールバック方針

計画を報告後、承認を得てから実装に進んでください。

【Phase 3: 実装】（目安: 1時間）
段階的に実装（一度に全部やらない）:
1. [ステップ1] → テスト → コミット
2. [ステップ2] → テスト → コミット
3. [ステップ3] → テスト → コミット

【Phase 4: 検証】（目安: 10分）
- 全テスト実行
- 既存機能の動作確認
- パフォーマンス確認
```

**使用例**:
```markdown
【対象】src/extractors/youtube_song_scraper.py（1,213行）
【理由】1ファイルが長すぎて保守性が低い
【方針】機能ごとに分割（スクレイピング/解析/エクスポート）

【Phase 1: 影響範囲調査】（目安: 10分）
Task tool (Explore agent, very thorough) で以下を調査:
- youtube_song_scraper.py を import している全ファイルを洗い出し
- 各ファイルでどの関数を使っているか特定
- テストコードの有無確認

【Phase 2: リファクタリング計画】（目安: 15分）
Task tool (Plan agent) で以下を立案:
- ファイル分割の案（scraper.py / analyzer.py / exporter.py）
- 各ステップでのテスト方法
- ロールバック方針（Git tag作成）

計画を報告後、承認を得てから実装に進んでください。

【Phase 3: 実装】（目安: 2時間）
段階的に実装（一度に全部やらない）:
1. analyzer.py を作成 → テスト → コミット
2. exporter.py を作成 → テスト → コミット
3. scraper.py をリファクタ → テスト → コミット
4. youtube_song_scraper.py から各モジュールをimport → テスト → コミット

【Phase 4: 検証】（目安: 10分）
- python update_web.py で既存機能の動作確認
- パフォーマンス確認（実行時間が変わっていないか）
```

---

## 失敗例と学び

### 失敗例1: 「いきなり実装」で3時間の無駄

**状況**:
```markdown
あなた: 「Spotify APIでジャンル取得機能を追加して」
Claude: （いきなり実装開始）
```

**結果**:
- 既存の `spotify_classifier.py` に気づかず、重複実装
- 3時間の無駄

**学び**:
```markdown
✅ 必ず Task tool (Explore agent) で既存実装を調査してから実装開始
```

---

### 失敗例2: 「曖昧な指示」で手戻り発生

**状況**:
```markdown
あなた: 「パフォーマンスを改善して」
Claude: （勝手に並列処理を導入）
```

**結果**:
- 並列処理でバグ発生
- 元に戻すのに1時間

**学び**:
```markdown
✅ 「何を」「どう」改善するのか具体的に指示
例: 「スクレイピング速度を改善したい。API呼び出しのバッチサイズを50→100に増やしてください」
```

---

### 失敗例3: 「影響範囲未確認」でバグ多発

**状況**:
```markdown
あなた: 「CSV出力フォーマットを変更して」
Claude: （export_to_web.py だけ修正）
```

**結果**:
- フロントエンドがデータを読み込めなくなる
- 2時間のバグ修正

**学び**:
```markdown
✅ Task tool (Explore agent) で影響範囲を事前調査
✅ CSVを読み込んでいる全ファイルを洗い出してから変更
```

---

## チェックリスト

### 指示を出す前のチェックリスト

- [ ] 既存の実装パターンを確認したか？（ファイルパスを明示）
- [ ] 5W1H（何を、どこに、なぜ、どうやって、いつまでに）を含めたか？
- [ ] Task tool（Explore/Plan）を使うべき状況か判断したか？
- [ ] 影響範囲を確認する指示を含めたか？
- [ ] 成功基準（どうなったら完了か）を明示したか？

### 実装後のチェックリスト

- [ ] 既存のテストが通るか？
- [ ] 新機能が期待通り動作するか？
- [ ] ビルドが成功するか？（`npm run build`）
- [ ] エッジケースをテストしたか？
- [ ] ドキュメント（README、claude.md）を更新したか？
- [ ] コミットメッセージは明確か？

---

## FAQ

### Q1: Task tool を使うべきか、直接指示すべきか迷う

**A**: 以下の基準で判断:

| 状況 | 判断 | 理由 |
|------|------|------|
| タイポ修正 | 直接指示 | Task tool のオーバーヘッドが無駄 |
| 既知のバグ修正（1箇所） | 直接指示 | 修正箇所が明確 |
| コメント追加 | 直接指示 | 簡単すぎる |
| 新機能追加 | Task tool | 既存実装の調査が必要 |
| リファクタリング | Task tool | 影響範囲の確認が必要 |
| 複数ファイルにまたがる修正 | Task tool | 見落としを防ぐ |

**迷ったら Task tool を使う**（コスト増は少ない、見落とし防止効果は大きい）

---

### Q2: Task tool で時間がかかりすぎる気がする

**A**: Task tool 自体は遅くない。以下を確認:

1. **適切なモデルを選択しているか？**
   - 簡単なタスク → Haiku（高速・低コスト）
   - 複雑なタスク → Sonnet（高品質）

2. **並列実行を活用しているか？**
   ```markdown
   ❌ 順次実行（3時間）:
   Task 1 → Task 2 → Task 3

   ✅ 並列実行（1時間）:
   Task 1, Task 2, Task 3 を同時実行
   ```

3. **thoroughness を適切に設定しているか？**
   ```markdown
   quick: 基本的な探索（5分）
   medium: 中程度の探索（10分）
   very thorough: 徹底的な探索（15分）← 推奨
   ```

---

### Q3: Claude が勝手に新しいパターンを作るのを防ぐには？

**A**: 以下の2つを徹底:

1. **必ず既存ファイルのパスを明示**
   ```markdown
   「src/extractors/youtube_song_scraper.py のパターンを完全に踏襲すること」
   ```

2. **具体的に「何を同じにするか」を列挙**
   ```markdown
   「特に以下の点を同じにすること：
   - エラーハンドリング（try-except の使い方）
   - ログ出力（print文のフォーマット）
   - データ構造（TimeStamp, VideoInfo の使い方）」
   ```

---

### Q4: 曖昧な指示をしてしまったらどうする？

**A**: Claude に「確認してから実装」を習慣づける

**claude.md に記載済みの対応**:
```markdown
### 3. 曖昧な指示には必ず聞き返す

ユーザー: 「ジャンル分類を改善して」
Claude: 「承知しました。効率的に進めるため、いくつか確認させてください：
1. どのジャンルの精度が低いですか？
2. 誤分類の具体例はありますか？
3. genre_keywords.json を編集する方法でよいですか？

確認後、以下の流れで進めます：...」
```

**あなたがすべきこと**:
- 曖昧な指示をしてしまったら、Claude の質問に丁寧に答える
- 次回からは具体的な指示を心がける

---

### Q5: 記録（cost.csv、指示履歴）は本当に必要？

**A**: 必要。理由は3つ:

1. **再現性の向上**
   - 「前回どうやったっけ？」を防ぐ
   - 成功パターンを再利用できる

2. **効果の検証**
   - トークン消費、時間、バグ数を定量的に把握
   - 改善の効果を数字で示せる

3. **チーム内での共有**
   - 他の人が同じ失敗を繰り返さない
   - ベストプラクティスを共有

**コスト**:
- 1タスクあたり1分程度（`/cost` コマンド実行 → cost.csv 追記）

**効果**:
- 次回以降の効率が **30%向上**

---

## まとめ

### 3つの黄金ルール（再掲）

1. **既存を見せる** → ファイルパスを明示して「このパターンを踏襲」
2. **具体的に伝える** → 5W1H（何を、どこに、なぜ、どうやって、いつまでに）
3. **影響範囲を確認** → Task tool (Explore agent) で事前調査

### 実績

| 指標 | 従来の方法 | このガイド活用後 | 削減効果 |
|------|-----------|----------------|---------|
| 開発時間 | 3.5時間 | 1.2時間 | **-66%** |
| トークン消費 | 200K | 120K | **-40%** |
| コスト | $3.00 | $1.80 | **-40%** |
| バグ数 | 3-5個 | 0-1個 | **-80%** |

### 次のステップ

1. **テンプレートをコピーして使う**
   - このガイドのテンプレートをコピペして指示を作成

2. **記録を始める**
   - `docs/metrics/cost.csv` にトークン消費を記録
   - `docs/instructions/YYYYMMDD_[topic].md` に指示履歴を記録

3. **週次レビュー**
   - 毎週末に `docs/metrics/weekly_review.md` を更新
   - Keep/Problem/Try で改善

---

**このガイドの更新ルール**:
- 新しい失敗例・成功例が出たら「実践例」に追記
- 新しい質問が出たら「FAQ」に追加
- 効果測定の結果を「まとめ」に反映

**次回レビュー**: 主要機能追加時、または月次